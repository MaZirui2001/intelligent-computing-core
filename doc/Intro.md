# 流水线微架构设计

## 1 总体介绍

本项目的处理器基于Tomasulo旁路算法，采用11或12级流水、多发射、乱序执行、顺序提交的方式进行构建。该处理器支持龙芯架构32位精简版指令集除IBAR和DBAR外的全部指令，可以稳定运行功能测试和性能测试，最大时钟频率达120MHz，运行CoreMark通用测试程序的IPC达0.834，系统运行稳定性有待测试验证。

按照指令流动的方式，该处理器的流水级可划分为：

* 前端：预取指、取指、预译码、译码、重命名
* 后端：发射、读寄存器堆、执行（地址转换、访存）、写回、提交

在前端中，指令保持程序中原有顺序流动，并在重命名阶段被打乱送入对应的功能单元发射队列。后端使用重排序缓存维护指令原有顺序，并通过乱序多发射的思想尽可能挖掘指令间的并行性。

## 2 指令支持

处理器支持龙芯架构32位精简版指令集中运行系统所需的全部指令，包括：

* 非特权架构：
  - 算数运算类指令：`ADD.W`, `SUB.W`, `ADDI.W`, `LU12I.W`, `SLT[U]`, `SLT[U]I`, `PCADDU12I`, `AND`, `OR`, `NOR`, `XOR`, `ANDI`, `ORI`, `XORI`, `MUL.W`, `MULH.W[U]`, `DIV.W[U]`, `MOD.W[U]`
  - 移位运算类指令：`SLL.W`, `SRL.W`, `SRA.W`, `SLLI.W`, `SRLI.W`, `SRAI.W`
  - 转移指令：`BEQ`, `BNE`, `BLT[U]`, `BGE[U]`, `B`, `BL`, `JIRL`
  - 普通访存指令：`LD.B`, `LD.H`, `LD.W`, `LD.BU`, `LD.HU`, `ST.B`, `ST.H`, `ST.W`
  - 其他杂项指令：`RDCNTVL.W`, `RDCNTVH.W`, `RDCNTID`, `SYSCALL`, `BREAK`
* 特权架构：
  - CSR访问指令：`CSRRD`, `CSRWR`, `CSRXCHG`
  - Cache维护指令：`CACOP`
  - TLB维护指令：`TLBSRCH`, `TLBRD`, `TLBWR`, `TLBFILL`, `INVTLB`
  - 其他杂项指令：`ERTN`

由于IBAR和DBAR的功能一般使用CACOP代为实现，故处理器未支持该指令。

## 3 前端基础流水线

该处理器采取双取指的实现方式，前端的每一个流水级在每个周期内至多运输两条指令。下面对各个流水级进行介绍：

### 3.1 预取指阶段

预取指阶段包括程序计数器（PC）、取指地址转换单元（Inst-TLB）和分支预测器构成。

该阶段产生两个顺序指令地址送入流水线，并使用这两个地址对分支指令的方向和目标地址进行预测。

若PC当前对齐4字节但不对齐8字节，虽然在大多数情况下指令高速缓存仍然可以给出两条指令，但为减少分支预测器的延时和复杂度，在当前的设计中，这种情况下仅会存在一条有效指令，下个周期取指地址依然会回到8字节对齐的状态。

### 3.2 取指阶段

取指阶段主要由指令高速缓存（ICache）构成。

由于地址转换已经在预取指阶段完成，故ICache的访问是基于物理地址的。若ICache命中，则会给出地址相邻的两条指令，否则流水线的前两个阶段将陷入阻塞，直至缺失的缓存块从内存中读出。

### 3.3 预译码阶段

在预译码阶段，处理器会对指令进行跳转检查，即在分支预测器没有记录该指令时：

* 若指令为直接必定跳转指令（BL、B），则预译码器会触发分支预测失败，并利用PC和指令中的立即数计算出正确地址，抹除前两个阶段的指令重新取指；
* 若指令为分支指令，则预译码器会根据立即数最高位判断跳转方向：若立即数为负数，则认为该指令为循环跳转指令，并触发分支预测失败重新取指，否则认为该指令不予跳转。
* 若指令不为任何跳转分支指令，则分支预测器一定将一条不为分支的指令判断为分支指令（这种情况在自修改程序中较为常见），此时预译码器触发分支预测失败，重新取指。

由于处理器的流水级较深，分支预测失败的代价过大。当分支预测器发生容量缺失时，预译码器可以及时纠正译码。在维护正确性方面，预译码器也阻止了“非跳转指令预测错误且不进入分支指令功能单元”这一影响正确性的情况发生。

经过预译码的指令会被送入取指队列。该队列由交叠实现的伪双端口FIFO实现，每个周期可以送入0~2条指令，并发射出0或2条指令。

### 3.4 译码阶段

译码阶段由译码器和空闲物理寄存器列表构成。

译码器借助Chisel中的BitPat自动生成组合逻辑，负责对从取指队列中发射出的至多2条指令进行译码，获得其寄存器、ALU操作数、访存类型、跳转类型等信号。

空闲物理寄存器列表为需要写寄存器堆的指令分配空闲物理寄存器，并从提交阶段获取待废除的物理寄存器。若空闲物理寄存器列表为空，则需要阻塞流水线前4个阶段，直至后端有待废除的物理寄存器提交至此。

### 3.5 重命名阶段

重命名阶段由寄存器映射表和分派器构成。

#### 3.5.1 重命名系统

在重命名系统中，寄存器映射表由CRat构成，采用全相连的方式，利用逻辑寄存器的编号和每一个存储单元分别比较，并获取到对应的物理寄存器编号及其当前是否滞留在发射队列的信息。同时，对于需要目的寄存器的指令，当前周期还会将表中的有效位置位，并标记其为“滞留于发射队列”的状态。由于每个周期有两条指令需要重命名，因此可能出现写后读和写后写相关，需要对读出的源寄存器编号进行修缮，并决定写后写时将哪个逻辑寄存器写入映射表。

每条指令不仅需要读出两个源寄存器对应的物理寄存器编号，还需要读出目的寄存器曾经对应的物理寄存器编号，这个编号作为待废除的物理寄存器编号，将会在提交阶段提交给空闲物理寄存器列表。

由于重命名处在推断状态，因此在提交阶段，处理器维护了另一个绝对正确的映射有效位表，当发生分支预测失败时，重命名阶段的有效位表会被设置为提交阶段的有效位表，从而实现了映射关系的恢复。

#### 3.5.2 分派器

分派器是连接处理器前端和后端的重要元件。这个单元会根据译码阶段给出的发射队列选择信号，为每一个发射队列提供如下信息：

* 当前周期需要进入该发射队列的指令掩码
* 当前周期需要进入该发射队列的指令处于这该指令组的哪个位置

对于功能相同的发射队列，分派器会比较当前这些发射队列中存在的指令总数，将指令送入总数较少的队列。

#### 3.5.3指令顺序的维护

在这个阶段，每一条指令会从重排序缓存（ROB）中获取1个顺序编号。这个编号将会伴随这条指令进入后端，直至其完成执行并顺序提交。若当前周期重排序缓存已满，则需要阻塞流水线前5个阶段，直至有指令提交。

## 4 后端基础流水线

处理器的后端有4个独立的功能单元，分别是：

* 算数逻辑运算单元（第一运算单元）：处理算数逻辑指令和计数器读取指令
* 算术逻辑&分支跳转单元（第二运算单元）：处理算数逻辑指令和分支跳转指令
* 乘除&特权处理单元：处理乘除法和特权指令
* 访存处理单元：处理器加载、存储和同步指令

### 4.1 发射与唤醒

处理器的发射队列采用压缩队列进行实现，其中算数逻辑运算单元和分支跳转单元的发射队列为乱序发射队列，而为了保证特权指令的顺序和龙芯架构32位精简版指令集中对于“强序非缓存”的定义，乘除和访存单元的发射队列为顺序发射队列。

#### 4.1.1 发射

发射队列的每个表项包括：

* 指令包：包含当前指令在后端所需的全部信号
* 寄存器唤醒标记：表示当前寄存器是否被前序指令唤醒
* 寄存器由加载指令唤醒标记：表示当前寄存器是否由加载指令唤醒

发射操作由发射队列和选择模块协同完成。这两个模块间使用Request-Acknowledge协议进行通讯。

顺序发射队列仅会在寄存器已经就绪时，使最旧的指令向选择模块发送发射请求，若后续流水线无阻塞，则选择模块会响应这个请求，并将指令发射到后续流水线中。而在乱序发射队列中，每一个有效表项都会向选择模块发送发射请求，而选择模块会使用优先编码器，响应其中最旧指令的请求，这是因为：

* 最旧的指令往往处于相关链顶端，发射后可以唤醒更多指令
* 对于读计数器指令，这种策略可以保证连续两条读取指令读取到的数据是循环递增的

#### 4.1.2 唤醒

发射队列中的每一个表项都会将自身的两个源寄存器编号与唤醒总线上的4个寄存器编号进行比较，若相等则将唤醒标记置位。在处理器中，有两处唤醒操作较为重要：

* **推测唤醒**：由于加载指令往往处于相关链的顶端，因此访存处理单元采取了推测唤醒的方式。在访存的第一个周期，该指令便开始唤醒其他指令，若唤醒成功则将加载指令唤醒标记置位。若下一个周期发现该指令发生了高速缓存缺失，则所有被当前指令唤醒的指令应当在缺失处理完成前滞留在发射队列中，否则正常发射即可。
* **相关指令连续发射**：算数逻辑指令占据了程序绝大部分比重，因此这些指令若能够在相关时连续发射，就能够对处理器性能有较大提升，故该处理器中算术逻辑队列的发射与唤醒在同一个周期内完成。

### 4.2 读寄存器堆

为了适应四个发射队列独立读取和写入，寄存器堆共有8个读端口和4个写端口，每一个读端口都配备了写优先。由于后端所有指令不可能出现目的寄存器相同的两条指令，因此写优先至多命中一个写数据，故可以将四个写入数据前递到每一个读端口上。

### 4.3 算数执行

该处理器共有两个ALU，支持龙芯架构32位精简版指令集规定的全部11种运算。其中：

* 第一运算单元承担了读取计数器值的功能
* 第二运算单元承担了为BL和JIRL指令计算PC+4的功能

### 4.4 乘法与除法

#### 4.4.1 华莱士树流水乘法

处理器的乘法单元采用了3级流水的华莱士树流水乘法，使用33位扩展乘法来实现龙芯架构32位精简版指令集中全部乘法指令。具体如下：

* 第一级：2位Booth编码，使用乘数将被乘数编码，将部分和的数量由32削减至16
* 第二级：8层66位保留进位加法器树，每层将部分和削减三分之一，直至剩余两个部分和
* 第三级：64位全加器，将最后两个部分和相加，得到最后结果。

#### 4.4.2 对数加速移位除法

除法和取余运算本质相同，都类似于竖式除法的方式进行移位相减。

当被除数较小时，竖式除法是没有必要使用32个周期完成运算的。因此，处理器在第一个周期取被除数的对数（即寻找最高位的1是第几位），记录在计数器中，除法开始后，只需要运行被除数的对数个周期，即可完成运算。

### 4.5 存储器访问

考虑到时序问题，访存流水线的设计与其余流水线有较大差别，也引入了一些特殊的部件。下面一一进行介绍

#### 4.5.1 发射与读取寄存器堆

由于访存队列是压缩的且是顺序发送的，因此寄存器堆的读地址只会来自发射队列的第0个表项，是相对固定的，故发射队列和寄存器堆之间没有段间寄存器堆，指令发射与读取寄存器堆是同步进行的。

#### 4.5.2 地址计算与TLB命中判断

TLB的全相连结构使其前后都不可有任何其他的组合逻辑，若存在组合逻辑，则需要对TLB读取进行切割，因此和取指不同，访存的TLB采用了两级切割。第一个流水级，访存单元计算出虚拟地址，并和TLB的每一个表项进行命中判断，将命中信息独热码送入段间寄存器。

在这个流水级，虚拟地址也被送入数据高速缓存（DCache），根据虚拟Index物理Tag原理，这个周期可以使用虚拟地址中的Index部分开始查找Tag和Data表所在的BRAM。

#### 4.5.3 TLB读取与标签比较

段间寄存器中的TLB命中独热码可以作为独热码，对TLB表项进行索引。索引出的结果将送入DCache，和读出的Tag进行比较，并将命中信息送入下一段间寄存器。

由于此阶段的访存请求都是推测的，因此写操作不能在此时产生效果，故这个阶段需要将写请求写入一个写缓冲（Store Buffer）中，当存储指令被提交时，该指令才会对高速缓存发起写操作。在执行加载指令时，也要同步查找写缓冲，查找方式如下：

* 对当前请求地址对应的4个字节分别进行全相连查找，将命中信息锁存一个周期
* 利用命中信息读取对应的写缓冲数据，当有多项命中时，根据尾指针的位置找到最近写入的数据

#### 4.5.4 高速缓存缺失判断与数据重组

为优化时序，高速缓存在获取到命中信息后，并不会立刻使用状态机进行缺失判断，而是锁存一个周期后送入状态机。

为了使得龙芯架构中的强序非缓存访问能够按照顺序确定地执行，所有的非可缓存访问都会滞留在这个阶段，直至这个访问被确认为是最旧的一条指令，流水线才会继续流动。

对于加载指令，其数据可能来自于高速缓存，也可能来自于写缓冲，因此在这个阶段需要根据写缓冲的命中情况，对数据进行拼接。

### 4.6 写回阶段

写回阶段将会对物理寄存器堆发起写操作，并标记重排序缓存对应表项的完成状态。

为了加速运算指令的执行，这个阶段在第一、二运算和访存流水线中架设了旁路网络：

* 第一、第二运算流水线可以相互前递数据，使得二者间的相关指令可以连续发射；
* 第一、第二运算和访存流水线可以将数据前递回访存流水线的地址计算阶段，压缩了访存的流水线级数

### 4.7 提交阶段

处理器的提交阶段负责维护处理器状态，主要包括重排序缓存（ROB）和状态恢复元件（ARAT）。

* ROB采用伪双端口交叠FIFO的形式实现，每个周期最多可以提交两条指令，在基础架构中，若头部指令不为跳转指令，则若ROB队列头部两条指令均完成执行，则会提交两条指令。
* ARAT中维护了寄存器映射表的有效位，可在分支预测失败时恢复到重命名单元中。同时，ARAT还维护了分支预测器返回地址栈的栈顶指针，在分支预测失败时，也会恢复到分支预测器中，对分支预测正确率有一定提升。

## 5 特权系统的支持

本节将会详细介绍流水线中对特权指令、中断异常的支持。

### 5.1 控制状态寄存器

* **CSR写指令对指令流的影响**：

  处理器可以对控制状态寄存器（CSR）进行读写。值得注意的是，除了读写，在触发异常、触发中断时CSR的值也会发生改变，这意味着控制状态寄存器的值变化可能会影响指令流（例如在写入CRMD寄存器后立刻执行特权不合法的特权指令）。考虑到CSR读写指令执行频率并不高，因此对CSR写指令采用执行后冲刷流水线的思路来实现。
* **CSR写指令的写入时机**：

  对CSR进行重命名的代价是比较大的，在没有重命名的情况下，写回段不能直接对CSR进行写入，而是应当在提交指令后再进行写入。为优化地址转换的时序，当CSR被写入时，处理器会多阻塞一个周期，用以将CSR信息锁存一个周期后送入TLB。
* **ROB对CSR写指令的支持**：

  CSR写指令由乘除模块进行处理，这个模块是顺序发射的，因此处理器在ROB中维护了一个缓冲区，CSR写地址、写数据等信息都会在执行阶段写入这个缓冲区，提交时由这个缓存对CSR发起写操作。

  由于CSR写指令一定会冲刷全部流水线，故在冲刷流水线前，缓冲区仅仅会记录最旧的CSR写请求，后续写请求将会被缓冲区无视

### 5.2 异常处理

龙芯架构32位精简版指令集规定了若干异常，根据触发地点不同可以分为：

* 前端：PIF，PPI，ADEF，SYS，BRK，INE，IPE，TLBR
* 后端：PIL，PIS，PME，PPI，ADEM，ALE，TLBR

注意到，后端的异常只会在访存流水线中产生，因此可以采用如下方法进行处理：

* 在译码阶段之前产生的所有异常，都会将产生异常的指令替换为一条 `mul $r0, $r0, $r0`指令，并在重命名阶段将异常写入重排序缓存
* 在译码阶段产生的异常，直接将其目标队列序号设置为乘除法队列，并将运算设置为乘法，并在重命名阶段将异常写入重排序缓存
* 由于只有加载和存储指令可能在后端触发异常，而能够在后端触发异常的加载和存储指令在前端一定没有触发异常（否则就将被替换为 `mul $r0, $r0, $r0`并送入乘除法队列）。因此，访存流水线会在写回段将后端产生的异常写入重排序缓存。并将这条指令附带的全部写入控制信号设置为无效。

### 5.3 中断处理

ESTAT寄存器在每个周期都会对中断源进行采样，一旦侦测到存在异常信号，就会立刻保存到ROB的缓冲区里，当下一条指令提交时，这条指令会被打上中断标记，并触发这个中断。

### 5.4 访存单元控制指令

#### 5.4.1 TLB读写与查找

TLB相关指令都由乘除法流水线进行处理。

* TLBRD：执行阶段读出对应的TLB表项，写入ROB的缓冲区中，提交时同步到CSR中
* TLBWR/TLBFILL：提交阶段将CSR中的值写入TLB中，TLBFILL使用了计数器的低4位进行随机化处理
* TLBSRCH：执行阶段查找TLB，找到命中的表项索引，写入ROB的缓冲区中，提交时同步到CSR中
* INVTLB：执行阶段将操作数写入ROB的缓冲区中，提交时对TLB进行处理

#### 5.4.2 Cache操作

CACOP指令涉及地址转换，因此需要送入访存流水线。CACOP必须保证：在执行之前所有的Store操作都已经完成，因此，CACOP会滞留在发射队列中，直到这条指令被确认为最旧的指令才会发射。

对于DCache而言，CACOP可以视为一次普通的无效果访存，而对于ICache而言，这条指令打断了正常取指的节奏，因此当CACOP提交后，流水线依然需要冲刷一次来恢复到正常的取指节奏。
